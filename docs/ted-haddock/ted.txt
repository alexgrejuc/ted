-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/alexgrejuc/ted#readme</a>
@package ted
@version 0.1.0.0


module Lib

-- | Successively apply a function n times.
appN :: Integral n => (a -> a) -> n -> a -> a

-- | Successively apply a function n times or until it reaches a fixpoint
appFix :: (Integral n, Eq a) => (a -> a) -> n -> a -> a

-- | Apply a function to both elements of a tuple
both :: (a -> b) -> (a, a) -> (b, b)

-- | Concatenate the elements of a container with an interspersed element
concatWith :: (Monoid a, Foldable t) => a -> t a -> a

-- | Concatenate the elements of a container. For use with Seq since I
--   couldn't use the prelude version on it
concatS :: (Monoid a, Foldable t) => t a -> a

-- | Split a Seq a into (init, last)
seqUnsnoc :: Seq a -> (Seq a, a)

-- | Split a Seq a into (head, tail)
seqUncons :: Seq a -> (a, Seq a)
pairDiff :: (Num a, Num b) => (a, b) -> (a, b) -> (a, b)

-- | Append operator for Text
(+++) :: Text -> Text -> Text

-- | Rounds up to a positive multiple of some base
roundUp :: Integral a => a -> a -> a


-- | The functions and data types for the creating and manipulating the
--   core data structure of the editor.
module Zipper
type Position = (Int, Int)

-- | A 2-d zipper representing the contents of a text file with newlines
--   stripped. A paragraph is represented by the Text to the left of the
--   currently-selected contents, and the Text to its right.
data Zipper
Zipper :: Seq Text -> Text -> Text -> Text -> Seq Text -> Zipper

-- | The paragraphs of text above the current line
[above] :: Zipper -> Seq Text

-- | The text left and above the current selection
[left] :: Zipper -> Text

-- | The current selection
[selection] :: Zipper -> Text

-- | The text right and below the current selection
[right] :: Zipper -> Text

-- | The paragraphs of text below the current line
[below] :: Zipper -> Seq Text
emptyZipper :: Zipper

-- | A not-so-smart constructor for a Zipper. If the underlying
--   representation of a Zipper is extended, old examples and test cases
--   might not have to be changed.
makeZipper :: Seq Text -> Text -> Text -> Text -> Seq Text -> Zipper

-- | Makes a Zipper with no lines above or below.
paragraph :: Text -> Text -> Text -> Zipper

-- | Makes the (left, selection, right) portion of a Zipper at the
--   specified column from a line of text.
--   
--   <pre>
--   &gt;&gt;&gt; fromLine 0 "123456789" == paragraph "" "1" "23456789"
--   True
--   </pre>
fromLine :: Int -> Text -> Zipper

-- | Split a Seq Text into (above, selection, below) at the specified row
--   (0-indexed).
splitThree :: Int -> Seq Text -> (Seq Text, Text, Seq Text)

-- | Makes a Zipper from Text by splitting on newlines.
--   
--   <pre>
--   &gt;&gt;&gt; fromText (0,0) "1\n2\n3\n" == makeZipper [] "" "1" "" ["2","3"]
--   True
--   </pre>
fromText :: Position -> Text -> Zipper
combineLine :: Zipper -> Text
toLines :: Zipper -> Seq Text

-- | Converts a Zipper into Text by interspersing newlines between all
--   lines. Obivated in editor by toText3 and only used for testing.
--   
--   <pre>
--   &gt;&gt;&gt; let text = "1\n2\n3\n4\n" in let z = fromText (1,1) text in text == toText z
--   True
--   </pre>
toText :: Zipper -> Text
parLen :: Zipper -> Int
parLines :: Int -> Zipper -> Int

-- | Converts the visible portion of a Zipper into the text before the
--   selection, the selection, and the text after the selection
toText3 :: Int -> Int -> Int -> Zipper -> (Text, Text, Text)
splitStart :: Int -> Zipper -> (Text, Text)

-- | Takes n lines of length w (or ending in a newline) from the text which
--   precedes the first line of the current selection
takeTop :: Int -> Int -> Zipper -> Seq Text
splitEnd :: Int -> Zipper -> (Text, Text)

-- | Takes n lines of length w (or ending in a newline) from the text which
--   follows the last line of the current selection
takeBottom :: Int -> Int -> Zipper -> Seq Text
atBottom :: Zipper -> Bool
atTop :: Zipper -> Bool
atEnd :: Zipper -> Bool

-- | Moves the cursor up one row. Does nothing if the cursor is already at
--   the topmost position.
--   
--   <pre>
--   &gt;&gt;&gt; upPar (makeZipper ["0", "1"] "1" "2" "3" ["b"]) == makeZipper ["0"] "" "1" "" ["123", "b"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upPar (makeZipper ["hi"] "1" "2" "3" ["b"]) == makeZipper [] "" "h" "i" ["123", "b"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upPar (makeZipper ["hello"] "1" "2" "3" []) == makeZipper [] "" "h" "ello" ["123"]
--   True
--   </pre>
upPar :: Zipper -> Zipper

-- | Moves up n rows
upPars :: Int -> Zipper -> Zipper

-- | Moves the cursor down one row. Does nothing if the cursor is already
--   at the bottommost position.
--   
--   <pre>
--   &gt;&gt;&gt; downPar (makeZipper ["0"] "" "1" "2" ["b", "c"]) == makeZipper ["0", "12"] "" "b" "" ["c"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; downPar (makeZipper [] "" "!" "" ["single"]) == makeZipper ["!"] "" "s" "ingle" []
--   True
--   </pre>
downPar :: Zipper -> Zipper

-- | Moves down n rows
downPars :: Int -> Zipper -> Zipper

-- | Moves the cursor left one column or to the end of the previous
--   paragraph if at the leftmost position
--   
--   <pre>
--   &gt;&gt;&gt; stepLeft numbers == paragraph "123" "4" "56789"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; goLeft 20 numbers == paragraph "" "1" "23456789"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toText (stepLeft numbers) == toText numbers
--   True
--   </pre>
stepLeft :: Zipper -> Zipper

-- | Moves left n times
goLeft :: Int -> Zipper -> Zipper

-- | Moves the cursor right one column. Does nothing if the cursor is
--   already at the rightmost position.
--   
--   <pre>
--   &gt;&gt;&gt; stepRight numbers == paragraph "12345" "6" "789"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; goRight 20 numbers == paragraph "123456789" "" ""
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toText (stepRight numbers) == toText numbers
--   True
--   </pre>
stepRight :: Zipper -> Zipper

-- | Moves right n columns
goRight :: Int -> Zipper -> Zipper

-- | Performs a move on a zipper (row, column). Vertically relative,
--   horizontally relative to the x position after the vertical move.
go :: Int -> (Int, Int) -> Zipper -> Zipper

-- | Moves down one visual line (e.g. n characters, the length of a line on
--   the screen)
--   
--   <pre>
--   &gt;&gt;&gt; stepDown 5 (paragraph "" "l" "ine line") == paragraph "line " "l" "ine"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepDown 20 (Zipper [] "between para" "" "" [""]) == Zipper ["between para"] "" "" "" []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepDown 20 (Zipper [] "between para" "" "" ["!"]) == Zipper ["between para"] "!" "" "" []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepDown 20 (Zipper [] "be" "t" "ween" ["!!!"]) == Zipper ["between"] "!!" "!" "" []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepDown 4 (Zipper [] "lin" "e" "l" ["not here"]) == Zipper [] "linel" "" "" ["not here"]
--   True
--   </pre>
stepDown :: Int -> Zipper -> Zipper
goDown :: Int -> Int -> Zipper -> Zipper

-- | Moves up one visual line (e.g. n characters, the length of a line on
--   the screen)
--   
--   <pre>
--   &gt;&gt;&gt; stepUp 2 (Zipper [] "abcde" "f" "" []) == Zipper [] "abc" "d" "ef" []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepUp 2 (Zipper [""] "" "a" "b" []) == Zipper [] "" "" "" ["ab"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepUp 10 (Zipper ["abcdef"] "" "g" "h" []) == Zipper [] "" "a" "bcdef" ["gh"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stepUp 10 (Zipper ["ab"] "cdef" "g" "h" []) == Zipper [] "ab" "" "" ["cdefgh"]
--   True
--   </pre>
stepUp :: Int -> Zipper -> Zipper
goUp :: Int -> Int -> Zipper -> Zipper
selectionPos :: Int -> Zipper -> (Position, Position)

-- | Returns a 0-indexed (row, column) cursor position based on lines of
--   length n
--   
--   <pre>
--   &gt;&gt;&gt; cursorStart 10 emptyZipper == (0,0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cursorStart 10 $ makeZipper ["0", "1", "2", "3"] "01234" "5" "6789" ["below"]
--   (4,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cursorStart 2 $ makeZipper ["0", "1", "2", "3"] "01234" "56" "6789" ["below"]
--   (6,1)
--   </pre>
cursorStart :: Int -> Zipper -> Position

-- | Returns a 0-indexed (row, column) cursor position based on lines of
--   length n
--   
--   <pre>
--   &gt;&gt;&gt; cursorEnd 10 emptyZipper == (0,0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cursorEnd 10 $ makeZipper ["0", "1", "2", "3"] "01234" "5" "6789" ["below"]
--   (4,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cursorEnd 2 $ makeZipper ["0", "1", "2", "3"] "01234" "56" "789" ["below"]
--   (7,0)
--   </pre>
cursorEnd :: Int -> Zipper -> Position
lsAbove :: Int -> Zipper -> Int

-- | Returns a 0-indexed (colStart, colEnd) cursor position based on lines
--   of length n
cursorCol :: Int -> Zipper -> Position

-- | Returns a 0-indexed (rowStart, rowEnd) cursor position based on lines
--   of length n
cursorRow :: Int -> Zipper -> Position

-- | Creates a new line from the current selection
--   
--   <pre>
--   &gt;&gt;&gt; split (paragraph "moves up" "d" "oesn't") == makeZipper ["moves up"] "" "d" "oesn't" []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (paragraph "" "stays" "put") == makeZipper [""] "" "stays" "put" []
--   True
--   </pre>
split :: Zipper -> Zipper

-- | Removes a character from <a>left</a>
--   
--   <pre>
--   &gt;&gt;&gt; backspace (paragraph "abc" "def" "ghi") == paragraph "ab" "def" "ghi"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; backspace (Zipper ["moves"] "" "u" "p" []) == Zipper [] "moves" "u" "p" []
--   True
--   </pre>
backspace :: Zipper -> Zipper

-- | Deletes the current selection
--   
--   <pre>
--   &gt;&gt;&gt; delete emptyZipper == emptyZipper
--   True
--   </pre>
--   
--   delete (paragraph "" <a>A</a> "") == emptyZipper True
--   
--   <pre>
--   &gt;&gt;&gt; delete (paragraph "abc" "d" "efg") == paragraph "abc" "e" "fg"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; delete (paragraph "abc" "de" "fg") == paragraph "abc" "f" "g"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; delete (Zipper [] "abc" "d" "" ["e"]) == Zipper [] "abc" "" "" ["e"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; delete (Zipper [] "text" "" "" ["moves up"]) == Zipper [] "text" "m" "oves up" []
--   True
--   </pre>
delete :: Zipper -> Zipper

-- | Appends a character to the left of the selection
appendChar :: Char -> Zipper -> Zipper

-- | Appends text to the left of the selection
appendText :: Text -> Zipper -> Zipper

-- | Extends the cursor to include the sentence which encloses the current
--   selection. Does not handle acronyms well.
--   
--   <pre>
--   &gt;&gt;&gt; selectSentence zSentences == zSentences'
--   True
--   </pre>
selectSentence :: Zipper -> Zipper
selectParagraph :: Zipper -> Zipper

-- | Applies a function to the selection
toSelection :: (Text -> Text) -> Zipper -> Zipper
toUpper :: Zipper -> Zipper
toLower :: Zipper -> Zipper
sentences :: String -> [(Text, Int)]

-- | Selects the text which is enclosed by some string s
selectEnclosed :: Text -> Zipper -> Zipper
selectWord :: Zipper -> Zipper
posDiff :: Int -> Zipper -> Zipper -> (Int, Int)
numbers :: Zipper
zSentences :: Zipper
zSentences' :: Zipper

-- | A zipper which can be manipulated in ghci in case a reviewer has
--   trouble building the project.
exampleZipper :: Zipper
ez :: Zipper
instance GHC.Classes.Eq Zipper.Zipper
instance GHC.Show.Show Zipper.Zipper


-- | The code for mapping user actions via keyboard to operations on the
--   zipper and to the display.
module Editor
data Mode
Insert :: Mode
Edit :: Mode
data TedState
TedState :: Mode -> Int -> Zipper -> String -> Text -> TedState
[mode] :: TedState -> Mode

-- | lines above top of the window
[offset] :: TedState -> Int
[text] :: TedState -> Zipper

-- | file path to save to
[path] :: TedState -> String

-- | clipboard contents
[clip] :: TedState -> Text
type MonadEditor a = StateT TedState Curses a
startState :: Zipper -> String -> TedState
runEditor :: TedState -> Curses ()
eventLoop :: MonadEditor ()
handleEvent :: Window -> Event -> MonadEditor ()
copy :: MonadEditor ()
paste :: Window -> MonadEditor ()

-- | Handles an edit mode event by making the corresponding zipper update
--   and displaying it
editEvent :: Window -> Event -> MonadEditor ()

-- | Handles an insert mode event by making the corresponding zipper update
--   and displaying it
insertEvent :: Window -> Event -> MonadEditor ()

-- | Maps a key press to the corresponding operation on the zipper
act :: Int -> Key -> Zipper -> Zipper
moveCursorInt :: Int -> Int -> Update ()
screenSizeInt :: Curses (Int, Int)
getCursorInt :: Window -> Curses (Int, Int)

-- | Draws a zipper to the terminal. Skips offset o lines from the
--   beginning of the zipper
draw :: Int -> Zipper -> Curses ()

-- | Updates the display based on the state of the zipper.
tedRender :: Window -> (Zipper -> Zipper) -> MonadEditor ()

-- | Converts an arrow key press to the (y,x) go-relative coordinates.
arrowToMove :: Int -> Zipper -> Key -> (Int, Int)
arrowKeys :: [Key]
isArrowKey :: Key -> Bool
toggleMode :: Mode -> Mode
write :: FilePath -> Zipper -> IO ()
instance GHC.Classes.Eq Editor.Mode
instance GHC.Show.Show Editor.Mode
